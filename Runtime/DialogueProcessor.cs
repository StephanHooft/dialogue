using System;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;

namespace StephanHooft.Dialogue
{
    /// <summary>
    /// A subsidiary class that processes <see cref="DialogueLine"/>s generated by a <see cref="DialogueManager"/>,
    /// based on an ink story. The rate and manner of text flow are directed by this base class, but all derived classes
    /// must implement a series of methods to determine how/where the results are displayed.
    /// <para>
    /// Text processed from a <see cref="DialogueLine"/> is subject to so-called "text flow directives", which include:
    /// <list type="bullet">
    /// <item>allow-rushing</item>
    /// <item>auto-advance</item>
    /// <item>force-wait (in ms)</item>
    /// <item>jump</item>
    /// <item>refuse-rushing</item>
    /// <item>speed (in chars/s)</item>
    /// <item>wait (in ms)</item>
    /// </list>
    /// </para>
    /// </summary>
    public abstract class DialogueProcessor : MonoBehaviour
    {
        #region Properties

        /// <summary>
        /// True if the <see cref="DialogueProcessor"/> is in the middle of processing a <see cref="DialogueLine"/>.
        /// </summary>
        public bool ProcessingDialogueLine
            => Crawler.BusyDisplayingText;

        /// <summary>
        /// The <see cref="DialogueProcessor"/>'s settings, related to dialogue speed and feedback.
        /// Can be modified directly.
        /// </summary>
        public DialogueProcessorSettings Settings
            => dialogueProcessorSettings;

        /// <summary>
        /// Return true if the <see cref="DialogueProcessor"/>'s interface for displaying dialogue has been
        /// opened.
        /// </summary>
        protected abstract bool DialogueInterfaceOpen { get; }
        
        private TextCrawler Crawler
            => crawler ??= new(dialogueProcessorSettings, SetLineText, SetVisibleCharacters, AddOneVisibleCharacter,
                        PlayDialogueFeedback);

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        #endregion
        #region Fields

        [SerializeField]
        private DialogueProcessorSettings dialogueProcessorSettings = new();

        private TextCrawler crawler;

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        #endregion
        #region Methods

        /// <summary>
        /// Takes a <see cref="DialogueLine"/> and process it.
        /// </summary>
        /// <param name="line">
        /// The <see cref="DialogueLine"/> to process.
        /// </param>
        /// <param name="cue">
        /// The <see cref="DialogueCue"/> (if any) to apply once the whole line has been processed.
        /// </param>
        /// <param name="AutoAdvanceCallback">
        /// A delgate to call if the <see cref="DialogueLine"/> contained an "auto-advance" text flow directive.
        /// </param>
        public async void ProcessDialogueLine(DialogueLine line, DialogueCue cue, Action AutoAdvanceCallback)
        {
            if (!DialogueInterfaceOpen)
                throw Exceptions.InterfaceNotOpen;
            if (Crawler.BusyDisplayingText)
                throw Exceptions.AlreadyProcessingLine;
            ClearDialogueChoices();
            SetDialogueCue(DialogueCue.None);
            ProcessDialogueLineTags(line.tags);
            Crawler.DisplayText(line.text);
            while (Crawler.BusyDisplayingText)
                await Task.Yield();
            if (this != null && enabled)
            {
                if (Crawler.AutoAdvanceRequested && cue == DialogueCue.CanContinue)
                    AutoAdvanceCallback.Invoke();
                else
                {
                    SetDialogueCue(cue);
                    if (line.choices.Length > 0)
                        OfferDialogueChoices(line.choices);
                }
            }
        }

        /// <summary>
        /// If waiting on a <see cref="DialogueLine"/> to be processed, this method can be used to "rush" that line.
        /// </summary>
        public void RushCurrentDialogueLine()
        {
            if (!Crawler.BusyDisplayingText)
                throw Exceptions.NoLineToRush;
            Crawler.Rush();
        }
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        #endregion
        #region Abstract Methods

        /// <summary>
        /// Open/show the <see cref="DialogueProcessor"/>'s interface for displaying dialogue.
        /// </summary>
        public abstract void OpenDialogueInterface();

        /// <summary>
        /// Close/hide the <see cref="DialogueProcessor"/>'s interface for displaying dialogue.
        /// </summary>
        public abstract void CloseDialogueInterface();

        /// <summary>
        /// A <see cref="DialogueLine"/> may come with <see cref="DialogueTag"/>s, as parsed by a
        /// <see cref="DialogueManager"/> from the following format: <code>label:value</code>
        /// This method should implement if/how the <see cref="DialogueProcessor"/> will process these tags.
        /// </summary>
        /// <param name="tags">
        /// The <see cref="DialogueTag"/>s, if any, to process.
        /// </param>
        protected abstract void ProcessDialogueLineTags(DialogueTag[] tags);

        /// <summary>
        /// Set <see cref="string"/> line text to be displayed, regardless of whether all characters are to be displayed
        /// immediately or not.
        /// </summary>
        /// <param name="text">
        /// The <see cref="string"/> text to be displayed.
        /// </param>
        protected abstract void SetLineText(string text);

        /// <summary>
        /// Determine how many characters of the latest line are visible.
        /// <para>A distinction is made between "visible" and "invisible" characters. Rich text tags, for example, are
        /// considered "invisible" and are therefore not counted when this method is called.</para>
        /// </summary>
        /// <param name="numberOfCharacters">
        /// The number of visible characters to display.
        /// </param>
        protected abstract void SetVisibleCharacters(int numberOfCharacters);

        /// <summary>
        /// Like <see cref="SetVisibleCharacters(int)"/>, this method is used to control how much of a processed line
        /// should be visible at a certain moment. This method in particular is used to gradually unfold a dialogue line
        /// over time.
        /// </summary>
        protected abstract void AddOneVisibleCharacter();

        /// <summary>
        /// If "dialogue feedback" is enabled, this method will be called periodically. Any feedback responses (such as
        /// playing dialogue audio), if any, must be implemented here.
        /// </summary>
        /// <param name="character">
        /// The text character currently being unveiled. Can be used as a deterministic parameter for feedback.
        /// </param>
        protected abstract void PlayDialogueFeedback(char character);

        /// <summary>
        /// A <see cref="DialogueLine"/> may come with <see cref="DialogueChoice"/>s. A choice must be made before the
        /// story can continue. This method must therefore implement a manner of showing these choices, and calling the
        /// appropriate <see cref="DialogueChoice.choiceCallback"/> method to confirm one of the choices.
        /// </summary>
        /// <param name="choices">
        /// The <see cref="DialogueChoice"/>s to display.
        /// </param>
        protected abstract void OfferDialogueChoices(DialogueChoice[] choices);

        /// <summary>
        /// Hide/clean up any <see cref="DialogueChoice"/>s that had previously been offered.
        /// </summary>
        protected abstract void ClearDialogueChoices();

        /// <summary>
        /// Display a visual cue matching the value of <paramref name="cue"/> that is passed.
        /// </summary>
        /// <param name="cue">
        /// The <see cref="DialogueCue"/> to set.
        /// </param>
        protected abstract void SetDialogueCue(DialogueCue cue);

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        #endregion
        #region DialogueProcessorSettings Class

        /// <summary>
        /// A simple data object containing settings referenced by a <see cref="DialogueProcessor"/>.
        /// </summary>
        [Serializable]
        public class DialogueProcessorSettings
        {
            /// <summary>
            /// Dialogue speed, expressed as characters-per-second.
            /// </summary>
            public int Speed
            {
                get => dialogueSpeed;
                set => dialogueSpeed = Mathf.Clamp(value, 1, 200);
            }

            /// <summary>
            /// Frequency of dialogue feedback to be generated, expressed as characters-per-second.
            /// </summary>
            public int FeedbackFrequency
            {
                get => feedbackFrequency;
                set => feedbackFrequency = Mathf.Clamp(value, 1, 200);
            }

            [SerializeField]
            [Range(1, 200)]
            private int dialogueSpeed = 30;

            /// <summary>
            /// Whether or not requests for dialogue feedback should be generated.
            /// </summary>
            public bool feedbackEnabled;

            [SerializeField]
            [Range(1, 200)]
            private int feedbackFrequency = 10;
        }
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        #endregion
        #region TextCrawler Class

        private class TextCrawler
        {
            public bool AutoAdvanceRequested
                => requestAutoAdvance;

            public bool BusyDisplayingText
                => textDisplayTask != null;

            public bool ForceWaiting
                => activeTextFlowDirective == TextFlowDirectiveType.ForceWait;

            public bool Jumping
                => activeTextFlowDirective == TextFlowDirectiveType.Jump;

            public bool TextFlowDirectiveActive
                => activeTextFlowDirective != TextFlowDirectiveType.CloseLink;

            public bool Waiting
                => waitTask != null && !waitTask.IsCompleted;

            private TextFlowDirectiveType activeTextFlowDirective = TextFlowDirectiveType.CloseLink;
            private bool requestAutoAdvance;
            private Task textDisplayTask;
            private int currentSpeed;
            private bool rushingPermitted = true;
            private Task waitTask;

            private readonly Action addOneVisibleCharacter;
            private readonly DialogueProcessorSettings settings;
            private readonly CharacterCounter feedbackCounter = new();
            private readonly Action<string> displayText;
            private readonly Action<char> triggerFeedback;
            private readonly BoolReference rushing = new(false);
            private readonly Action<int> setVisibleCharacters;
            private readonly TextFlowDirectiveParser tagParser = new();

            public TextCrawler(DialogueProcessorSettings settings, Action<string> displayText,
                Action<int> setVisibleCharacters, Action addOne, Action<char> triggerFeedback)
            {
                this.displayText = displayText;
                this.settings = settings;
                this.setVisibleCharacters = setVisibleCharacters;
                addOneVisibleCharacter = addOne;
                this.triggerFeedback = triggerFeedback;
            }

            public async void DisplayText(string text)
            {
                textDisplayTask = TextDisplayTask(text);
                try { await textDisplayTask; }
                catch (Exception e) { throw e; }
                finally
                {
                    textDisplayTask = null;
                    activeTextFlowDirective = TextFlowDirectiveType.CloseLink;
                }
            }

            public void Rush()
            {
                if (BusyDisplayingText && rushingPermitted && !ForceWaiting)
                    rushing.SetValue(true);
            }

            private async Task TextDisplayTask(string text)
            {
                feedbackCounter.Reset();
                tagParser.Reset();
                requestAutoAdvance = false;
                rushing.SetValue(false);
                currentSpeed = settings.Speed;
                displayText.Invoke(text);
                setVisibleCharacters.Invoke(0);
                var array = text.ToCharArray();
                foreach (var letter in array)
                {
                    if (!ParsingRichTextTag(letter) && !rushing)
                    {
                        addOneVisibleCharacter.Invoke();
                        if (!Jumping)
                        {
                            if (settings.feedbackEnabled
                            && !char.IsWhiteSpace(letter)
                            && feedbackCounter.AddOne(currentSpeed / settings.FeedbackFrequency))
                                triggerFeedback.Invoke(letter);
                            await Task.Delay(1000 / currentSpeed);
                        }
                    }
                    while (Waiting && !rushing)
                        await Task.Yield();
                }
                setVisibleCharacters.Invoke(array.Length);
            }

            private bool ParsingRichTextTag(char letter)
            {
                if (letter == '<' && !tagParser.Parsing)
                    tagParser.BeginTag();
                else if (letter == '>' && tagParser.Parsing)
                {
                    if(tagParser.EndTag(out var textFlowTag))
                        ProcessTextFlowTag(textFlowTag);
                    return true;
                }
                else if (tagParser.Parsing)
                    tagParser.AppendToTag(letter);
                return tagParser.Parsing;
            }

            private void ProcessTextFlowTag(TextFlowDirective textFlowTag)
            {
                var type = textFlowTag.type;
                var arguments = textFlowTag.arguments;
                if (TextFlowDirectiveActive && type != TextFlowDirectiveType.CloseLink)
                    throw Exceptions.LinkTagAlreadyOpen;
                switch (type)
                {
                    case TextFlowDirectiveType.AllowRushing:
                        rushingPermitted = true;
                        break;
                    case TextFlowDirectiveType.AutoAdvance:
                        requestAutoAdvance = true;
                        break;
                    case TextFlowDirectiveType.CloseLink:
                        if (TextFlowDirectiveActive)
                        {
                            currentSpeed = settings.Speed;
                            waitTask = null;
                        }
                        break;
                    case TextFlowDirectiveType.ForceWait:
                        Wait(arguments);
                        break;
                    case TextFlowDirectiveType.Jump:
                        break;
                    case TextFlowDirectiveType.RefuseRushing:
                        rushingPermitted = false;
                        break;
                    case TextFlowDirectiveType.Speed:
                        SetDisplaySpeed(arguments);
                        break;
                    case TextFlowDirectiveType.Wait:
                        Wait(arguments);
                        break;                    
                    default:
                        throw Exceptions.DirectiveNotImplemented(type);
                }
                activeTextFlowDirective = type;
            }

            private void SetDisplaySpeed(string arguments)
            {
                if (int.TryParse(arguments, out var number))
                    currentSpeed = number;
            }

            private void Wait(string arguments)
            {
                if (int.TryParse(arguments, out var number))
                {
                    feedbackCounter.Reset();
                    waitTask = Task.Delay(number);
                }
            }
        }
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        #endregion
        #region BoolReference Class

        private class BoolReference
        {
            private bool value;

            public BoolReference(bool value)
            {
                this.value = value;
            }

            public void SetValue(bool value)
            {
                this.value = value;
            }

            public static implicit operator bool(BoolReference reference)
            => reference.value;
        }
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        #endregion
        #region CharacterCounter Class

        private class CharacterCounter
        {
            private int count;

            public bool AddOne(int comparator)
            {
                var ping = count == 0;
                count++;
                if (count >= Mathf.Max(1, comparator))
                    count = 0;
                return ping;
            }

            public void Reset()
            {
                count = 0;
            }
        }
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        #endregion
        #region TextFlowDirectiveParser Class

        private class TextFlowDirectiveParser
        {
            public bool Parsing
                => parsing;

            private bool parsing;
            private readonly StringBuilder tagStringBuilder = new();

            public void AppendToTag(char character)
            {
                tagStringBuilder.Append(character);
            }

            public void BeginTag()
            {
                tagStringBuilder.Clear();
                parsing = true;
            }
            
            public bool EndTag(out TextFlowDirective directive)
            {
                parsing = false;
                if (ParseLinkTag(tagStringBuilder.ToString(), out directive))
                    return true;
                return false;
            }

            public void Reset()
            {
                tagStringBuilder.Clear();
                parsing = false;
            }

            private static bool ParseLinkTag(string tag, out TextFlowDirective directive)
            {
                directive = default;
                if (tag.Equals("/link"))
                    directive = new(TextFlowDirectiveType.CloseLink, "close");
                else if (tag.Length > 6 && tag.StartsWith("link=\"") && tag.EndsWith("\""))
                {
                    var trimmedTag = tag[6..].TrimEnd('"');
                    var splitTag = trimmedTag.Split('=');
                    if(splitTag.Length == 1)
                    {
                        directive = splitTag[0] switch
                        {
                            "allow-rushing" => new(TextFlowDirectiveType.AllowRushing),
                            "auto-advance" => new(TextFlowDirectiveType.AutoAdvance),
                            "jump" => new(TextFlowDirectiveType.Jump),
                            "refuse-rushing" => new(TextFlowDirectiveType.RefuseRushing),
                            _ => default,
                        };
                    }
                    else if(splitTag.Length == 2)
                    {
                        var arguments = splitTag[1];
                        directive = splitTag[0] switch
                        {
                            "force-wait" => new(TextFlowDirectiveType.ForceWait, arguments),
                            "speed" => new(TextFlowDirectiveType.Speed, arguments),
                            "wait" => new(TextFlowDirectiveType.Wait, arguments),
                            _ => default,
                        };
                    }
                }
                return directive != default;
            }
        }
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        #endregion
        #region TextFlowDirectiveType Enum
        private enum TextFlowDirectiveType
        {
            AllowRushing,
            AutoAdvance,
            CloseLink,
            ForceWait,
            Jump,
            RefuseRushing,
            Speed,
            Wait,
        }
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        #endregion
        #region TextFlowDirective Struct

        private readonly struct TextFlowDirective
        {
            public readonly TextFlowDirectiveType type;
            public readonly string arguments;

            public TextFlowDirective(TextFlowDirectiveType type)
            {
                this.type = type;
                arguments = "";
            }

            public TextFlowDirective(TextFlowDirectiveType type, string arguments)
            {
                this.type = type;
                this.arguments = arguments;
            }

            public static bool operator ==(TextFlowDirective a, TextFlowDirective b)
                => a.type == b.type && a.arguments == b.arguments;

            public static bool operator !=(TextFlowDirective a, TextFlowDirective b)
                => a.type != b.type || a.arguments != b.arguments;

            public override bool Equals(object obj)
            {
                if (obj is not TextFlowDirective)
                    return false;
                var tag = (TextFlowDirective)obj;
                return type == tag.type && arguments == tag.arguments;
            }

            public override int GetHashCode()
                => HashCode.Combine(type, arguments);
        }
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        #endregion
        #region Exceptions

        private static class Exceptions
        {
            public static InvalidOperationException AlreadyProcessingLine
                => new($"{DialogueProcessor} is already processing a {DialogueLine}.");

            public static NotImplementedException DirectiveNotImplemented(TextFlowDirectiveType type)
                => new($"{TextFlowDirective} of type {type} has not been implemented.");

            public static Exception InterfaceNotOpen
                => new($"{DialogueProcessor} cannot process a {DialogueLine} when its interface is not open.");

            public static InvalidOperationException LinkTagAlreadyOpen
                => new($"Cannot process {TextFlowDirective}. A <link> tag was left open. " +
                    $"Ensure <link> tags are closed with '</link>' before a new one occurs.");

            public static InvalidOperationException NoLineToRush
                => new($"Cannot rush: {DialogueProcessor} is is not processing a {DialogueLine}.");

            private static string DialogueProcessor
                => typeof(DialogueProcessor).Name;

            private static string DialogueLine
                => typeof(DialogueLine).Name;

            private static string TextFlowDirective
                => typeof(TextFlowDirective).Name;
        }
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        #endregion
    }
}
